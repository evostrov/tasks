'''
Быстрая сортировка

Выбираем любой элемент x, остальной массив разделям на две части.
Первая - элементы меньше или равные x, второй - больше.
Рекурсивно выполняем тоже самое с получившимися двумя массивами,
результаты мерджим последовательно, так как они получаются отсортированными.

В среднем время работы не больше чем O(nlogn). Но на отсортированных данных
и в случае если все элементы равны между собой,
алгоритм может отработать за время работы O(n^2),
так как если брать за x всегда брать первый элемент,
то мы будем всегда получать первый подмассив нулевой длинны.
И надо будет выполнить n - k на каждом k-ом разделении, k = 0..n-1.
Но в среднем при случайном выборе величины для разделения
время работы O(nlogn), но не хуже O(n^2).

Если во входном массиве ожидаются равные данные, то стоит делать деление
на три части <, >, ==. Тогда время работы не будет квадратичным.

Интроспективная сортировка - в худшем случае работает не дольшем чем O(nlogn).
Для этого числом разделителем выбирается медиана из интервала от первого до последнего элемента
входных данных. Но если глубина разбиения в ходе работы превышает nlog, то прерываемся
и используем другой алгоритм.

Еще можно избавится от двойной рекурсии заменив ее на цикл, оставив только
один уровень рекурсии.

Но на практике он будет работать быстрее чем сортировка слиянием,
так как константные выражения в оценке меньше и перестановок будет меньше.
А так же экономит память так как работает на месте.

INPUT:
1 43 2 5 65

OUTPUT:
1 2 5 43 65
'''

import random

def partition(A):
    # Выбираем рандомный x
    x = A.pop(random.randint(0, len(A)-1))
    return x, [e for e in A if e <= x], [e for e in A if e > x]


def quick_sort(A):
    if len(A) == 1: return A
    if len(A) == 0: return []
    x, left, right = partition(A)
    return [ *quick_sort(left), x, *quick_sort(right) ]


def main():
    A = [ int(x) for x in str.split(input()) ]

    print(' '.join([ str(x) for x in quick_sort(A) ]))


if __name__ == "__main__":
    main()
