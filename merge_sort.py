'''
Сортировка слиянием рекурсивно

Рекурсивно делим массив на двое пока не дойдем до массива длинной в 1 элемент.
При выходе из рекурсии сливаем массивы сравнивая элементы из полученных массивов.

Время работы не больше чем O(nlogn).
Так как количество делений массива будет не больше чем степень двойки, если
делим массив из 8-и элементов, то будет выполнено 3 деления,
когда получим единичные массивы, 8 есть 2 в 3 степени, то есть log3 по основанию 2.
В каждом слияние выолняем не более чем n действий.
В итоге получаем nlogn.

INPUT:
1 43 2 5 65

OUTPUT:
1 2 5 43 65
'''
import math

def merge(A1, A2):
    res = []
    j1 = j2 = 0;

    # Мерджим два массива сравнивая и сортируя их поэлементно
    while (j1 < len(A1) and j2 < len(A2)):
        if (A1[j1] < A2[j2]):
            res.append(A1[j1])
            j1 += 1
        else:
            res.append(A2[j2])
            j2 += 1

    # Обязательно должен остаться хвост из 1-ого или больше элементов - его домержим в конец
    if j1 < len(A1):
        res.extend(A1[j1:])
    elif j2 < len(A2):
        res.extend(A2[j2:])

    return res

def merge_sort(A):
    if len(A) == 1 : return A
    v = math.ceil(len(A) / 2)
    return merge(merge_sort(A[:v]), merge_sort(A[v:]))


def main():
    A = [ int(x) for x in str.split(input()) ]

    print(' '.join([ str(x) for x in merge_sort(A) ]))


if __name__ == "__main__":
    main()
